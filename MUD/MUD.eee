// IDEAS
// be able to import packs from a disk, so you can hot swap packs if you want to save disk space for load times
// dialer needs to be tweaked, especially how you never need readings for time adddresses
// have script edit itself, reserve 40 (38 really, only 2 required files) blank lines to be written to via a pack import command
// load a disk full of packs, then you can have mud copy the file over/delete/whatever, edit itself to import it/rebuild include list, since it's not pasting it should work? 
// implement pager
// implement vfs compactor
// tombstone delete?
// apparently you can put a date string into the gate and im dumb, and that fixes the bug i had of not being able to dial months before oct because it'd delete the zero

// first-party packs ----------------
// doesn't cause any issues if they're missing from your file system
// if the packs don't work, try to MANUALLY TYPE the entire include line.
// My theory: pasting introduces hidden non-ascii that breaks the import. 
// OH MY GOD IT'S PASTING FROM VISUAL STUDIO DOING IT IM GONNA SCREAM


#include shell.mud
#include dumb.mud
#include crab.mud

// MUD.eee: entry point -------------
VFS_FILE = "MUD.vfs"
MUD_VERSION = "0.2"
MUD_API_VERSION = "1"
SCREEN_COLS = 64
DEFAULT_SCREEN_RGB = "15,10,5"

if countlines(VFS_FILE) == 0 then
  create VFS_FILE
end if

// utils ----------------------------

// print+breakline
// featuring chunking because screen wrap bug
println = function(s)
  if s == null then
    breakline
    return
  end if
  t = str(s)
  start = 0
  while start < t.len
    stop = start + SCREEN_COLS
    if stop > t.len then stop = t.len
    print t[start:stop]
    breakline
    start = stop
  end while
  if t.len == 0 then breakline
end function

// regular println (unused)
printline = function(s)
  print s
  breakline
end function

starts = function(s, p)
  if p.len > s.len then return 0
  return s[0:p.len] == p
end function

joinWith = function(lst, sep)
  out = ""
  i = 0
  for x in lst
    if i > 0 then out = out + sep
    out = out + str(x)
    i = i + 1
  end for
  return out
end function

spaces = function(n)
  out = ""
  i = 0
  while i < n
    out = out + " "
    i = i + 1
  end while
  return out
end function

cwd = "/"
normalize = function(p)
  if p == null then return "/"
  if p.len == 0 then return "/"
  if p[0] != "/" then p = cwd + "/" + p
  parts = p.split("/")
  stack = []
  for part in parts
    if part == "" or part == "." then
      // skip
    else if part == ".." then
      if stack.len > 0 then stack.pop
    else
      stack.push(part)
    end if
  end for
  if stack.len == 0 then return "/"
  return "/" + joinWith(stack, "/")
end function

clamp255 = function(n)
  if n < 0 then return 0
  if n > 255 then return 255
  return n
end function

bg_last = ""
apply_bg = function(force)
  cfg = vfs_get("/etc/mud/config/bg")
  if cfg == null then cfg = DEFAULT_SCREEN_RGB
  if force != 1 and cfg == bg_last then return

  parts = cfg.split(",")
  r = 45; g = 30; b = 15
  if parts.len >= 1 then r = clamp255(val(parts[0]))
  if parts.len >= 2 then g = clamp255(val(parts[1]))
  if parts.len >= 3 then b = clamp255(val(parts[2]))

  bgcolor(r, g, b)
  bg_last = cfg
end function

// VFS encoding ---------------------
// using char(x), no escapes because they don't seem to work
DELIM = "|"
PERC = "%"
LF = char(10)
CR = char(13)
BS = (
"    __  __ _   _ ____" + LF +
"   |  " + char(92) + "/  | | | |  _ " + char(92) + LF +
"   | |" + char(92) + "/| | | | | | | |" + LF +
"   | |  | | |_| | |_| |" + LF +
"   |_|  |_|" + char(92) + "___/|____/" + LF +
"~~~_~_~=~__~==~__=~_~_~~~")


enc = function(s)
  s = s.replace(PERC, "%25")
  s = s.replace(DELIM, "%7C")
  s = s.replace(LF, "%0A")
  s = s.replace(CR, "%0D")
  return s
end function

dec = function(s)
  s = s.replace("%0D", CR)
  s = s.replace("%0A", LF)
  s = s.replace("%7C", DELIM)
  s = s.replace("%25", PERC)
  return s
end function

// VFS primitives -------------------
// physical append uses 1-based lines
vfs_append = function(op, p, v)
  line = op + DELIM + normalize(p) + DELIM + enc(v)
  n = countlines(VFS_FILE)
  writeline VFS_FILE, n + 1, line
end function

vfs_set = function(p, v)
  vfs_append("SET", p, v)
end function
vfs_del = function(p)
  vfs_append("DEL", p, "")
end function

vfs_get = function(p)
  p = normalize(p)
  n = countlines(VFS_FILE)
  i = n
  while i >= 1
    rec = readfile(VFS_FILE, i)
    if rec != "" then
      cols = rec.split(DELIM)
      if cols.len >= 2 then
        op = cols[0]
        path = cols[1]
        if path == p then
          if op == "DEL" then return null
          if cols.len >= 3 then return dec(cols[2]) else return ""
        end if
      end if
    end if
    i = i - 1
  end while
  return null
end function

// skeleton (first boot) ------------
vfs_touchdir = function(p)
  p = normalize(p)
  vfs_set(p + "/.keep", "dir")
end function

vfs_init_skeleton = function()
  if vfs_get("/etc/mud/initialized") != null then return

  dirs = [
    "/etc", "/etc/mud", "/etc/mud/state",
    "/bin",
    "/usr", "/usr/bin", "/usr/local", "/usr/local/bin",
    "/var", "/var/log",
    "/tmp",
    "/home", "/home/mud", // trailing comma required
  ]
  for d in dirs
    vfs_touchdir(d)
  end for

  if vfs_get("/etc/mud/state/cwd") == null then vfs_set("/etc/mud/state/cwd", "/home/mud")
  if vfs_get("/etc/mud/bootscreen") == null then vfs_set("/etc/mud/bootscreen", BS)
  if vfs_get("/etc/mud/config/boot_enabled") == null then vfs_set("/etc/mud/config/boot_enabled", "1")
  if vfs_get("/etc/mud/config/header_enabled") == null then vfs_set("/etc/mud/config/header_enabled", "1")
  if vfs_get("/etc/mud/config/bg") == null then vfs_set("/etc/mud/config/bg", DEFAULT_SCREEN_RGB)
  vfs_set("/etc/mud/version", "1")
  vfs_set("/etc/mud/initialized", "1")

end function

state_load = function()
  val = vfs_get("/etc/mud/state/cwd")
  if val != null then cwd = normalize(val) else cwd = "/"
end function

state_save = function()
  vfs_set("/etc/mud/state/cwd", cwd)
end function

// block printer respects wrapping
print_block = function(txt)
  if txt == null then return
  lines = txt.split(LF)
  for L in lines
    println(L)
  end for
end function

// header ---------------------------
weekday_name = function(y, m, d)
  w = getweekday(y, m, d) // 0=Sun
  names = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]
  return names[w]
end function

month_name = function(m)
  names = ["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
  return names[m]
end function

// adds 0 to single digit numbers
two = function(n)
  if n < 10 then return "0" + str(n)
  return str(n)
end function

format_now = function()
  y = getyear()
  mo = getmonth()
  d = getday()
  h = gethour()
  mi = getminute()

  mer = "AM"
  if h >= 12 then mer = "PM"
  h12 = h
  if h12 == 0 then h12 = 12
  if h12 > 12 then h12 = h12 - 12

  wd = weekday_name(y, mo, d)
  mn = month_name(mo)

  ys = str(y)
  if y < 0 then ys = str(0 - y) + "BC"

  return wd + " " + str(h12) + ":" + two(mi) + mer + " " + mn + " " + str(d) + " " + ys
end function

render_header = function(cmdline)
  leftBase = "[MUD]>" + cmdline
  right = format_now()

  // reserve space for right block
  maxLeft = SCREEN_COLS - right.len
  if maxLeft < 1 then maxLeft = 1

  // add "..." when truncated
  left = leftBase
  if leftBase.len > maxLeft then
    keep = maxLeft - 3
    if keep < 0 then keep = 0
    left = leftBase[0:keep] + "..."
  end if

  gap = SCREEN_COLS - left.len - right.len
  if gap < 1 then gap = 1

  println(left + spaces(gap) + right)
end function

// init -----------------------------
vfs_init_skeleton()
state_load()
apply_bg(1)
if vfs_get("/etc/mud/config/boot_enabled") == "1" then
  clear
  if vfs_get("/etc/mud/config/header_enabled") == "1" then
    render_header("")
  end if
  print_block(vfs_get("/etc/mud/bootscreen"))
end if

// verb registry --------------------
verbs = {}
helps = {}
longhelps = {}

register = function(name, fn, help="")
  verbs[name] = fn
  if help != "" then helps[name] = help
end function

autoreg = function()
  g = globals
  for k in g.indexes
    if starts(k, "verb_") then
      nm = k[5:]
      verbs[nm] = g[k]
      hk = "help_" + nm
      if g.hasIndex(hk) then helps[nm] = g[hk]
      hk2 = "help_" + nm + "_long"
      if g.hasIndex(hk2) then longhelps[nm] = g[hk2]
    end if
  end for
end function

// verbs ---------------------------
verb_help = function(args)
  if args.len >= 1 then
    show_help(args[0])
    return
  end if
  ks = verbs.indexes
  ks.sort
  for k in ks
    line = k
    if helps.hasIndex(k) then line = line + "  - " + helps[k]
    println(line)
  end for
end function

show_help = function(name)
  n = name.lower
  if not verbs.hasIndex(n) then
    println("no such command: " + n)
    return
  end if
  line = n
  if helps.hasIndex(n) then line = line + "  - " + helps[n]
  println(line)
  if longhelps.hasIndex(n) then
    println("")
    print_block(longhelps[n])
  end if
end function

verb_mud = function(args)
  if args.len == 0 then
    println("usage: mud version | mud boot [show|on|off] | mud header [show|on|off] | mud bg [show|set <r> <g> <b>|reset]")
    return
  end if

  sub = args[0].lower

  if sub == "version" then
    println("mud " + MUD_VERSION + "  api " + MUD_API_VERSION)
    return
  end if

  if sub == "boot" then
    if args.len == 1 then
      st = vfs_get("/etc/mud/config/boot_enabled")
      if st == null then st = "1"
      println("boot: " + st)
      return
    end if
    act = args[1].lower
    if act == "show" then
      print_block(vfs_get("/etc/mud/bootscreen"))
      return
    end if
    if act == "on" then
      vfs_set("/etc/mud/config/boot_enabled", "1")
      println("boot enabled")
      return
    end if
    if act == "off" then
      vfs_set("/etc/mud/config/boot_enabled", "0")
      println("boot disabled")
      return
    end if
    println("usage: mud boot [show|on|off]")
    return
  end if

  if sub == "motd" then
    if args.len == 1 then
      st = vfs_get("/etc/mud/config/motd_enabled")
      if st == null then st = "1"
      println("motd: " + st)
      return
    end if
    act = args[1].lower
    if act == "show" then
      println(vfs_get("/etc/mud/motd"))
      return
    end if
    if act == "on" then
      vfs_set("/etc/mud/config/motd_enabled", "1")
      println("motd enabled")
      return
    end if
    if act == "off" then
      vfs_set("/etc/mud/config/motd_enabled", "0")
      println("motd disabled")
      return
    end if
    println("usage: mud motd [show|on|off]")
    return
  end if

  if sub == "header" then
    if args.len == 1 then
      st = vfs_get("/etc/mud/config/header_enabled")
      if st == null then st = "1"
      println("header: " + st)
      return
    end if
    act = args[1].lower
    if act == "on" then
      vfs_set("/etc/mud/config/header_enabled", "1")
      println("header enabled")
      return
    end if
    if act == "off" then
      vfs_set("/etc/mud/config/header_enabled", "0")
      println("header disabled")
      return
    end if
    if act == "show" then
      render_header("last")
      return
    end if
    println("usage: mud header [show|on|off]")
    return
  end if

if sub == "bg" then
  if args.len == 1 or args[1].lower == "show" then
    cfg = vfs_get("/etc/mud/config/bg"); if cfg == null then cfg = DEFAULT_SCREEN_RGB
    println("bg: " + cfg)
    return
  end if
  act = args[1].lower
  if act == "reset" then
    vfs_set("/etc/mud/config/bg", DEFAULT_SCREEN_RGB)
    apply_bg(1)
    println("bg reset")
    return
  end if
  if act == "set" then
    if args.len < 5 then
      println("usage: mud bg set <r> <g> <b>")
      return
    end if
    cfg = args[2] + "," + args[3] + "," + args[4]
    vfs_set("/etc/mud/config/bg", cfg)
    apply_bg(1)
    println("bg " + cfg)
    return
  end if
  println("usage: mud bg [show|set <r> <g> <b>|reset]")
  return
end if

  println("unknown mud subcommand")
end function
helps["mud"] = "version and config (boot, header, bg)"

verb_clear = function(args)
  clear
end function
helps["clear"] = "clear screen"

// register verbs now that they exist
autoreg()

// tokenizer ------------------------
// char(34) quotes
wsTab = char(9)
dq = char(34)
tokenize = function(s)
  toks = []
  t = ""
  q = 0
  i = 0
  while i < s.len
    c = s[i]
    if q then
      if c == dq then
        q = 0
        toks.push(t)
        t = ""
      else
        t = t + c
      end if
    else
      if c == dq then
        if t.len > 0 then
          toks.push(t)
          t = ""
        end if
        q = 1
      else if c == " " or c == wsTab then
        if t.len > 0 then
          toks.push(t)
          t = ""
        end if
      else
        t = t + c
      end if
    end if
    i = i + 1
  end while
  if t.len > 0 then toks.push(t)
  return toks
end function

// REPL -----------------------------
running = 1
while running
  yield
  line = readline
  if line == null or line.len == 0 then continue

  if vfs_get("/etc/mud/config/header_enabled") == "1" then
    clear
    render_header(line)
  end if


  toks = tokenize(line)
  if toks.len == 0 then continue
  cmd = toks[0].lower

  args = []
  i = 1
  while i < toks.len
    args.push(toks[i])
    i = i + 1
  end while

  // command-specific help flags
  wantHelp = 0
  j = 0
  while j < args.len
    a = args[j].lower
    if a == "-h" or a == "--help" then wantHelp = 1
    j = j + 1
  end while
  if wantHelp then
    show_help(cmd)
    continue
  end if


  if verbs.hasIndex(cmd) then
    fn = verbs[cmd]
    fn(args)
  else
    println("unknown: " + cmd + "  (try help)")
  end if
end while
